From 39cfe4bf0de93ac9ce57785950747ca8bcccfedb Mon Sep 17 00:00:00 2001
From: Zuzana Svetlikova <zsvetlik@redhat.com>
Date: Fri, 20 Jan 2017 09:29:55 -0500
Subject: [PATCH] Disable c tests

---
 test/disabled/test-crypto-dh.js             |  264 +++++++++++++++++++++++++++
 test/disabled/test-crypto-fips.js           |  201 ++++++++++++++++++++
 test/disabled/test-tls-cnnic-whitelist.js   |   84 +++++++++
 test/disabled/test-tls-dhe.js               |   95 ++++++++++
 test/disabled/test-tls-ecdh-disable.js      |   37 ++++
 test/disabled/test-tls-ecdh.js              |   40 ++++
 test/disabled/test-tls-empty-sni-context.js |   43 +++++
 test/disabled/test-tls-ocsp-callback.js     |  131 +++++++++++++
 test/disabled/test-tls-pfx-gh-5100-regr.js  |   40 ++++
 test/disabled/test-tls-securepair-server.js |  133 ++++++++++++++
 test/disabled/test-tls-sni-option.js        |  170 +++++++++++++++++
 test/disabled/test-tls-sni-server-client.js |  116 ++++++++++++
 test/parallel/test-crypto-dh.js             |  264 ---------------------------
 test/parallel/test-crypto-fips.js           |  201 --------------------
 test/parallel/test-tls-cnnic-whitelist.js   |   84 ---------
 test/parallel/test-tls-dhe.js               |   95 ----------
 test/parallel/test-tls-ecdh-disable.js      |   37 ----
 test/parallel/test-tls-ecdh.js              |   40 ----
 test/parallel/test-tls-empty-sni-context.js |   43 -----
 test/parallel/test-tls-ocsp-callback.js     |  131 -------------
 test/parallel/test-tls-pfx-gh-5100-regr.js  |   40 ----
 test/parallel/test-tls-securepair-server.js |  133 --------------
 test/parallel/test-tls-sni-option.js        |  170 -----------------
 test/parallel/test-tls-sni-server-client.js |  116 ------------
 24 files changed, 1354 insertions(+), 1354 deletions(-)
 create mode 100644 test/disabled/test-crypto-dh.js
 create mode 100644 test/disabled/test-crypto-fips.js
 create mode 100644 test/disabled/test-tls-cnnic-whitelist.js
 create mode 100644 test/disabled/test-tls-dhe.js
 create mode 100644 test/disabled/test-tls-ecdh-disable.js
 create mode 100644 test/disabled/test-tls-ecdh.js
 create mode 100644 test/disabled/test-tls-empty-sni-context.js
 create mode 100644 test/disabled/test-tls-ocsp-callback.js
 create mode 100644 test/disabled/test-tls-pfx-gh-5100-regr.js
 create mode 100644 test/disabled/test-tls-securepair-server.js
 create mode 100644 test/disabled/test-tls-sni-option.js
 create mode 100644 test/disabled/test-tls-sni-server-client.js
 delete mode 100644 test/parallel/test-crypto-dh.js
 delete mode 100644 test/parallel/test-crypto-fips.js
 delete mode 100644 test/parallel/test-tls-cnnic-whitelist.js
 delete mode 100644 test/parallel/test-tls-dhe.js
 delete mode 100644 test/parallel/test-tls-ecdh-disable.js
 delete mode 100644 test/parallel/test-tls-ecdh.js
 delete mode 100644 test/parallel/test-tls-empty-sni-context.js
 delete mode 100644 test/parallel/test-tls-ocsp-callback.js
 delete mode 100644 test/parallel/test-tls-pfx-gh-5100-regr.js
 delete mode 100644 test/parallel/test-tls-securepair-server.js
 delete mode 100644 test/parallel/test-tls-sni-option.js
 delete mode 100644 test/parallel/test-tls-sni-server-client.js

diff --git a/test/disabled/test-crypto-dh.js b/test/disabled/test-crypto-dh.js
new file mode 100644
index 0000000..6a067be
--- /dev/null
+++ b/test/disabled/test-crypto-dh.js
@@ -0,0 +1,264 @@
+'use strict';
+const common = require('../common');
+const assert = require('assert');
+
+if (!common.hasCrypto) {
+  common.skip('missing crypto');
+  return;
+}
+const crypto = require('crypto');
+const DH_NOT_SUITABLE_GENERATOR = crypto.constants.DH_NOT_SUITABLE_GENERATOR;
+
+// Test Diffie-Hellman with two parties sharing a secret,
+// using various encodings as we go along
+var dh1 = crypto.createDiffieHellman(common.hasFipsCrypto ? 1024 : 256);
+var p1 = dh1.getPrime('buffer');
+var dh2 = crypto.createDiffieHellman(p1, 'buffer');
+var key1 = dh1.generateKeys();
+var key2 = dh2.generateKeys('hex');
+var secret1 = dh1.computeSecret(key2, 'hex', 'base64');
+var secret2 = dh2.computeSecret(key1, 'latin1', 'buffer');
+
+assert.equal(secret1, secret2.toString('base64'));
+assert.equal(dh1.verifyError, 0);
+assert.equal(dh2.verifyError, 0);
+
+assert.throws(function() {
+  crypto.createDiffieHellman([0x1, 0x2]);
+});
+
+assert.throws(function() {
+  crypto.createDiffieHellman(function() { });
+});
+
+assert.throws(function() {
+  crypto.createDiffieHellman(/abc/);
+});
+
+assert.throws(function() {
+  crypto.createDiffieHellman({});
+});
+
+// Create "another dh1" using generated keys from dh1,
+// and compute secret again
+var dh3 = crypto.createDiffieHellman(p1, 'buffer');
+var privkey1 = dh1.getPrivateKey();
+dh3.setPublicKey(key1);
+dh3.setPrivateKey(privkey1);
+
+assert.deepStrictEqual(dh1.getPrime(), dh3.getPrime());
+assert.deepStrictEqual(dh1.getGenerator(), dh3.getGenerator());
+assert.deepStrictEqual(dh1.getPublicKey(), dh3.getPublicKey());
+assert.deepStrictEqual(dh1.getPrivateKey(), dh3.getPrivateKey());
+assert.equal(dh3.verifyError, 0);
+
+var secret3 = dh3.computeSecret(key2, 'hex', 'base64');
+
+assert.equal(secret1, secret3);
+
+// Run this one twice to make sure that the dh3 clears its error properly
+{
+  const c = crypto.createDecipheriv('aes-128-ecb', crypto.randomBytes(16), '');
+  assert.throws(function() { c.final('utf8'); }, /wrong final block length/);
+}
+
+assert.throws(function() {
+  dh3.computeSecret('');
+}, /key is too small/i);
+
+{
+  const c = crypto.createDecipheriv('aes-128-ecb', crypto.randomBytes(16), '');
+  assert.throws(function() { c.final('utf8'); }, /wrong final block length/);
+}
+
+// Create a shared using a DH group.
+var alice = crypto.createDiffieHellmanGroup('modp5');
+var bob = crypto.createDiffieHellmanGroup('modp5');
+alice.generateKeys();
+bob.generateKeys();
+var aSecret = alice.computeSecret(bob.getPublicKey()).toString('hex');
+var bSecret = bob.computeSecret(alice.getPublicKey()).toString('hex');
+assert.equal(aSecret, bSecret);
+assert.equal(alice.verifyError, DH_NOT_SUITABLE_GENERATOR);
+assert.equal(bob.verifyError, DH_NOT_SUITABLE_GENERATOR);
+
+/* Ensure specific generator (buffer) works as expected.
+ * The values below (modp2/modp2buf) are for a 1024 bits long prime from
+ * RFC 2412 E.2, see https://tools.ietf.org/html/rfc2412. */
+var modp2 = crypto.createDiffieHellmanGroup('modp2');
+var modp2buf = Buffer.from([
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f,
+  0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
+  0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67,
+  0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
+  0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95,
+  0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b, 0x30, 0x2b, 0x0a, 0x6d,
+  0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
+  0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
+  0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff,
+  0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38, 0x6b, 0xfb,
+  0x5a, 0x89, 0x9f, 0xa5, 0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b,
+  0x1f, 0xe6, 0x49, 0x28, 0x66, 0x51, 0xec, 0xe6, 0x53, 0x81,
+  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
+]);
+var exmodp2 = crypto.createDiffieHellman(modp2buf, Buffer.from([2]));
+modp2.generateKeys();
+exmodp2.generateKeys();
+var modp2Secret = modp2.computeSecret(exmodp2.getPublicKey()).toString('hex');
+var exmodp2Secret = exmodp2.computeSecret(modp2.getPublicKey()).toString('hex');
+assert.equal(modp2Secret, exmodp2Secret);
+assert.equal(modp2.verifyError, DH_NOT_SUITABLE_GENERATOR);
+assert.equal(exmodp2.verifyError, DH_NOT_SUITABLE_GENERATOR);
+
+
+// Ensure specific generator (string with encoding) works as expected.
+var exmodp2_2 = crypto.createDiffieHellman(modp2buf, '02', 'hex');
+exmodp2_2.generateKeys();
+modp2Secret = modp2.computeSecret(exmodp2_2.getPublicKey()).toString('hex');
+var exmodp2_2Secret = exmodp2_2.computeSecret(modp2.getPublicKey())
+                               .toString('hex');
+assert.equal(modp2Secret, exmodp2_2Secret);
+assert.equal(exmodp2_2.verifyError, DH_NOT_SUITABLE_GENERATOR);
+
+
+// Ensure specific generator (string without encoding) works as expected.
+var exmodp2_3 = crypto.createDiffieHellman(modp2buf, '\x02');
+exmodp2_3.generateKeys();
+modp2Secret = modp2.computeSecret(exmodp2_3.getPublicKey()).toString('hex');
+var exmodp2_3Secret = exmodp2_3.computeSecret(modp2.getPublicKey())
+                               .toString('hex');
+assert.equal(modp2Secret, exmodp2_3Secret);
+assert.equal(exmodp2_3.verifyError, DH_NOT_SUITABLE_GENERATOR);
+
+
+// Ensure specific generator (numeric) works as expected.
+var exmodp2_4 = crypto.createDiffieHellman(modp2buf, 2);
+exmodp2_4.generateKeys();
+modp2Secret = modp2.computeSecret(exmodp2_4.getPublicKey()).toString('hex');
+var exmodp2_4Secret = exmodp2_4.computeSecret(modp2.getPublicKey())
+                               .toString('hex');
+assert.equal(modp2Secret, exmodp2_4Secret);
+assert.equal(exmodp2_4.verifyError, DH_NOT_SUITABLE_GENERATOR);
+
+
+var p = 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' +
+        '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' +
+        '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' +
+        'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF';
+var bad_dh = crypto.createDiffieHellman(p, 'hex');
+assert.equal(bad_dh.verifyError, DH_NOT_SUITABLE_GENERATOR);
+
+
+// Test ECDH
+const ecdh1 = crypto.createECDH('prime256v1');
+const ecdh2 = crypto.createECDH('prime256v1');
+key1 = ecdh1.generateKeys();
+key2 = ecdh2.generateKeys('hex');
+secret1 = ecdh1.computeSecret(key2, 'hex', 'base64');
+secret2 = ecdh2.computeSecret(key1, 'latin1', 'buffer');
+
+assert.equal(secret1, secret2.toString('base64'));
+
+// Oakley curves do not clean up ERR stack, it was causing unexpected failure
+// when accessing other OpenSSL APIs afterwards.
+crypto.createECDH('Oakley-EC2N-3');
+crypto.createHash('sha256');
+
+// Point formats
+assert.equal(ecdh1.getPublicKey('buffer', 'uncompressed')[0], 4);
+let firstByte = ecdh1.getPublicKey('buffer', 'compressed')[0];
+assert(firstByte === 2 || firstByte === 3);
+firstByte = ecdh1.getPublicKey('buffer', 'hybrid')[0];
+assert(firstByte === 6 || firstByte === 7);
+
+// ECDH should check that point is on curve
+const ecdh3 = crypto.createECDH('secp256k1');
+const key3 = ecdh3.generateKeys();
+
+assert.throws(function() {
+  ecdh2.computeSecret(key3, 'latin1', 'buffer');
+});
+
+// ECDH should allow .setPrivateKey()/.setPublicKey()
+const ecdh4 = crypto.createECDH('prime256v1');
+
+ecdh4.setPrivateKey(ecdh1.getPrivateKey());
+ecdh4.setPublicKey(ecdh1.getPublicKey());
+
+assert.throws(function() {
+  ecdh4.setPublicKey(ecdh3.getPublicKey());
+}, /Failed to convert Buffer to EC_POINT/);
+
+// Verify that we can use ECDH without having to use newly generated keys.
+const ecdh5 = crypto.createECDH('secp256k1');
+
+// Verify errors are thrown when retrieving keys from an uninitialized object.
+assert.throws(function() {
+  ecdh5.getPublicKey();
+}, /Failed to get ECDH public key/);
+assert.throws(function() {
+  ecdh5.getPrivateKey();
+}, /Failed to get ECDH private key/);
+
+// A valid private key for the secp256k1 curve.
+const cafebabeKey = 'cafebabe'.repeat(8);
+// Associated compressed and uncompressed public keys (points).
+const cafebabePubPtComp =
+'03672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3';
+const cafebabePubPtUnComp =
+'04672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3' +
+'2e02c7f93d13dc2732b760ca377a5897b9dd41a1c1b29dc0442fdce6d0a04d1d';
+ecdh5.setPrivateKey(cafebabeKey, 'hex');
+assert.equal(ecdh5.getPrivateKey('hex'), cafebabeKey);
+// Show that the public point (key) is generated while setting the private key.
+assert.equal(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
+
+// Compressed and uncompressed public points/keys for other party's private key
+// 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF
+const peerPubPtComp =
+'02c6b754b20826eb925e052ee2c25285b162b51fdca732bcf67e39d647fb6830ae';
+const peerPubPtUnComp =
+'04c6b754b20826eb925e052ee2c25285b162b51fdca732bcf67e39d647fb6830ae' +
+'b651944a574a362082a77e3f2b5d9223eb54d7f2f76846522bf75f3bedb8178e';
+
+const sharedSecret =
+'1da220b5329bbe8bfd19ceef5a5898593f411a6f12ea40f2a8eead9a5cf59970';
+
+assert.equal(ecdh5.computeSecret(peerPubPtComp, 'hex', 'hex'), sharedSecret);
+assert.equal(ecdh5.computeSecret(peerPubPtUnComp, 'hex', 'hex'), sharedSecret);
+
+// Verify that we still have the same key pair as before the computation.
+assert.equal(ecdh5.getPrivateKey('hex'), cafebabeKey);
+assert.equal(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
+
+// Verify setting and getting compressed and non-compressed serializations.
+ecdh5.setPublicKey(cafebabePubPtComp, 'hex');
+assert.equal(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
+assert.equal(ecdh5.getPublicKey('hex', 'compressed'), cafebabePubPtComp);
+ecdh5.setPublicKey(cafebabePubPtUnComp, 'hex');
+assert.equal(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
+assert.equal(ecdh5.getPublicKey('hex', 'compressed'), cafebabePubPtComp);
+
+// Show why allowing the public key to be set on this type does not make sense.
+ecdh5.setPublicKey(peerPubPtComp, 'hex');
+assert.equal(ecdh5.getPublicKey('hex'), peerPubPtUnComp);
+assert.throws(function() {
+  // Error because the public key does not match the private key anymore.
+  ecdh5.computeSecret(peerPubPtComp, 'hex', 'hex');
+}, /Invalid key pair/);
+
+// Set to a valid key to show that later attempts to set an invalid key are
+// rejected.
+ecdh5.setPrivateKey(cafebabeKey, 'hex');
+
+[ // Some invalid private keys for the secp256k1 curve.
+  '0000000000000000000000000000000000000000000000000000000000000000',
+  'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141',
+  'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF',
+].forEach(function(element, index, object) {
+  assert.throws(function() {
+    ecdh5.setPrivateKey(element, 'hex');
+  }, /Private key is not valid for specified curve/);
+  // Verify object state did not change.
+  assert.equal(ecdh5.getPrivateKey('hex'), cafebabeKey);
+});
diff --git a/test/disabled/test-crypto-fips.js b/test/disabled/test-crypto-fips.js
new file mode 100644
index 0000000..55b542c
--- /dev/null
+++ b/test/disabled/test-crypto-fips.js
@@ -0,0 +1,201 @@
+'use strict';
+var common = require('../common');
+var assert = require('assert');
+var spawnSync = require('child_process').spawnSync;
+var path = require('path');
+
+if (!common.hasCrypto) {
+  common.skip('missing crypto');
+  return;
+}
+
+const FIPS_ENABLED = 1;
+const FIPS_DISABLED = 0;
+const FIPS_ERROR_STRING = 'Error: Cannot set FIPS mode';
+const OPTION_ERROR_STRING = 'bad option';
+const CNF_FIPS_ON = path.join(common.fixturesDir, 'openssl_fips_enabled.cnf');
+const CNF_FIPS_OFF = path.join(common.fixturesDir, 'openssl_fips_disabled.cnf');
+var num_children_ok = 0;
+
+function compiledWithFips() {
+  return process.config.variables.openssl_fips ? true : false;
+}
+
+function addToEnv(newVar, value) {
+  var envCopy = {};
+  for (const e in process.env) {
+    envCopy[e] = process.env[e];
+  }
+  envCopy[newVar] = value;
+  return envCopy;
+}
+
+function testHelper(stream, args, expectedOutput, cmd, env) {
+  const fullArgs = args.concat(['-e', 'console.log(' + cmd + ')']);
+  const child = spawnSync(process.execPath, fullArgs, {
+    cwd: path.dirname(process.execPath),
+    env: env
+  });
+
+  console.error('Spawned child [pid:' + child.pid + '] with cmd ' +
+      cmd + ' and args \'' + args + '\'');
+
+  function childOk(child) {
+    console.error('Child #' + ++num_children_ok +
+        ' [pid:' + child.pid + '] OK.');
+  }
+
+  function responseHandler(buffer, expectedOutput) {
+    const response = buffer.toString();
+    assert.notEqual(0, response.length);
+    if (FIPS_ENABLED !== expectedOutput && FIPS_DISABLED !== expectedOutput) {
+      // In the case of expected errors just look for a substring.
+      assert.notEqual(-1, response.indexOf(expectedOutput));
+    } else {
+      // Normal path where we expect either FIPS enabled or disabled.
+      assert.equal(expectedOutput, response);
+    }
+    childOk(child);
+  }
+
+  responseHandler(child[stream], expectedOutput);
+}
+
+// By default FIPS should be off in both FIPS and non-FIPS builds.
+testHelper(
+  'stdout',
+  [],
+  FIPS_DISABLED,
+  'require("crypto").fips',
+  addToEnv('OPENSSL_CONF', ''));
+
+// --enable-fips should turn FIPS mode on
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  ['--enable-fips'],
+  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
+  'require("crypto").fips',
+  process.env);
+
+//--force-fips should turn FIPS mode on
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  ['--force-fips'],
+  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
+  'require("crypto").fips',
+  process.env);
+
+// OpenSSL config file should be able to turn on FIPS mode
+testHelper(
+  'stdout',
+  [`--openssl-config=${CNF_FIPS_ON}`],
+  compiledWithFips() ? FIPS_ENABLED : FIPS_DISABLED,
+  'require("crypto").fips',
+  process.env);
+// OPENSSL_CONF should _not_ be able to turn on FIPS mode
+testHelper(
+  'stdout',
+  [],
+  FIPS_DISABLED,
+  'require("crypto").fips',
+  addToEnv('OPENSSL_CONF', CNF_FIPS_ON));
+
+// --enable-fips should take precedence over OpenSSL config file
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  ['--enable-fips', `--openssl-config=${CNF_FIPS_OFF}`],
+  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
+  'require("crypto").fips',
+  process.env);
+// OPENSSL_CONF should _not_ make a difference to --enable-fips
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  ['--enable-fips'],
+  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
+  'require("crypto").fips',
+  addToEnv('OPENSSL_CONF', CNF_FIPS_OFF));
+
+// --force-fips should take precedence over OpenSSL config file
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  ['--force-fips', `--openssl-config=${CNF_FIPS_OFF}`],
+  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
+  'require("crypto").fips',
+  process.env);
+// Using OPENSSL_CONF should not make a difference to --force-fips
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  ['--force-fips'],
+  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
+  'require("crypto").fips',
+  addToEnv('OPENSSL_CONF', CNF_FIPS_OFF));
+
+// setFipsCrypto should be able to turn FIPS mode on
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  [],
+  compiledWithFips() ? FIPS_ENABLED : FIPS_ERROR_STRING,
+  '(require("crypto").fips = true,' +
+  'require("crypto").fips)',
+  process.env);
+
+// setFipsCrypto should be able to turn FIPS mode on and off
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  [],
+  compiledWithFips() ? FIPS_DISABLED : FIPS_ERROR_STRING,
+  '(require("crypto").fips = true,' +
+  'require("crypto").fips = false,' +
+  'require("crypto").fips)',
+  process.env);
+
+// setFipsCrypto takes precedence over OpenSSL config file, FIPS on
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  [`--openssl-config=${CNF_FIPS_OFF}`],
+  compiledWithFips() ? FIPS_ENABLED : FIPS_ERROR_STRING,
+  '(require("crypto").fips = true,' +
+  'require("crypto").fips)',
+  process.env);
+
+// setFipsCrypto takes precedence over OpenSSL config file, FIPS off
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  [`--openssl-config=${CNF_FIPS_ON}`],
+  compiledWithFips() ? FIPS_DISABLED : FIPS_ERROR_STRING,
+  '(require("crypto").fips = false,' +
+  'require("crypto").fips)',
+  process.env);
+
+// --enable-fips does not prevent use of setFipsCrypto API
+testHelper(
+  compiledWithFips() ? 'stdout' : 'stderr',
+  ['--enable-fips'],
+  compiledWithFips() ? FIPS_DISABLED : OPTION_ERROR_STRING,
+  '(require("crypto").fips = false,' +
+  'require("crypto").fips)',
+  process.env);
+
+// --force-fips prevents use of setFipsCrypto API
+testHelper(
+  'stderr',
+  ['--force-fips'],
+  compiledWithFips() ? FIPS_ERROR_STRING : OPTION_ERROR_STRING,
+  'require("crypto").fips = false',
+  process.env);
+
+// --force-fips and --enable-fips order does not matter
+testHelper(
+  'stderr',
+  ['--force-fips', '--enable-fips'],
+  compiledWithFips() ? FIPS_ERROR_STRING : OPTION_ERROR_STRING,
+  'require("crypto").fips = false',
+  process.env);
+
+//--enable-fips and --force-fips order does not matter
+testHelper(
+  'stderr',
+  ['--enable-fips', '--force-fips'],
+  compiledWithFips() ? FIPS_ERROR_STRING : OPTION_ERROR_STRING,
+  'require("crypto").fips = false',
+  process.env);
diff --git a/test/disabled/test-tls-cnnic-whitelist.js b/test/disabled/test-tls-cnnic-whitelist.js
new file mode 100644
index 0000000..f16698c
--- /dev/null
+++ b/test/disabled/test-tls-cnnic-whitelist.js
@@ -0,0 +1,84 @@
+'use strict';
+var common = require('../common');
+var assert = require('assert');
+
+if (!common.hasCrypto) {
+  common.skip('missing crypto');
+  return;
+}
+
+var tls = require('tls');
+var fs = require('fs');
+var path = require('path');
+var finished = 0;
+
+function filenamePEM(n) {
+  return path.join(common.fixturesDir, 'keys', n + '.pem');
+}
+
+function loadPEM(n) {
+  return fs.readFileSync(filenamePEM(n));
+}
+
+var testCases = [
+  { // Test 0: for the check of a cert not existed in the whitelist.
+    // agent7-cert.pem is issued by the fake CNNIC root CA so that its
+    // hash is not listed in the whitelist.
+    // fake-cnnic-root-cert has the same subject name as the original
+    // rootCA.
+    serverOpts: {
+      key: loadPEM('agent7-key'),
+      cert: loadPEM('agent7-cert')
+    },
+    clientOpts: {
+      port: undefined,
+      rejectUnauthorized: true,
+      ca: [loadPEM('fake-cnnic-root-cert')]
+    },
+    errorCode: 'CERT_REVOKED'
+  },
+  // Test 1: for the fix of node#2061
+  // agent6-cert.pem is signed by intermidate cert of ca3.
+  // The server has a cert chain of agent6->ca3->ca1(root) but
+  // tls.connect should be failed with an error of
+  // UNABLE_TO_GET_ISSUER_CERT_LOCALLY since the root CA of ca1 is not
+  // installed locally.
+  {
+    serverOpts: {
+      ca: loadPEM('ca3-key'),
+      key: loadPEM('agent6-key'),
+      cert: loadPEM('agent6-cert')
+    },
+    clientOpts: {
+      port: undefined,
+      rejectUnauthorized: true
+    },
+    errorCode: 'UNABLE_TO_GET_ISSUER_CERT_LOCALLY'
+  }
+];
+
+function runTest(tindex) {
+  var tcase = testCases[tindex];
+
+  if (!tcase) return;
+
+  var server = tls.createServer(tcase.serverOpts, function(s) {
+    s.resume();
+  }).listen(0, function() {
+    tcase.clientOpts = this.address().port;
+    var client = tls.connect(tcase.clientOpts);
+    client.on('error', function(e) {
+      assert.strictEqual(e.code, tcase.errorCode);
+      server.close(function() {
+        finished++;
+        runTest(tindex + 1);
+      });
+    });
+  });
+}
+
+runTest(0);
+
+process.on('exit', function() {
+  assert.equal(finished, testCases.length);
+});
diff --git a/test/disabled/test-tls-dhe.js b/test/disabled/test-tls-dhe.js
new file mode 100644
index 0000000..92ab415
--- /dev/null
+++ b/test/disabled/test-tls-dhe.js
@@ -0,0 +1,95 @@
+'use strict';
+var common = require('../common');
+var assert = require('assert');
+
+if (!common.hasCrypto) {
+  common.skip('missing crypto');
+  return;
+}
+var tls = require('tls');
+
+var spawn = require('child_process').spawn;
+var fs = require('fs');
+var key = fs.readFileSync(common.fixturesDir + '/keys/agent2-key.pem');
+var cert = fs.readFileSync(common.fixturesDir + '/keys/agent2-cert.pem');
+var nsuccess = 0;
+var ntests = 0;
+var ciphers = 'DHE-RSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';
+
+
+function loadDHParam(n) {
+  var path = common.fixturesDir;
+  if (n !== 'error') path += '/keys';
+  return fs.readFileSync(path + '/dh' + n + '.pem');
+}
+
+function test(keylen, expectedCipher, cb) {
+  var options = {
+    key: key,
+    cert: cert,
+    ciphers: ciphers,
+    dhparam: loadDHParam(keylen)
+  };
+
+  var server = tls.createServer(options, function(conn) {
+    conn.end();
+  });
+
+  server.on('close', function(err) {
+    assert(!err);
+    if (cb) cb();
+  });
+
+  server.listen(0, '127.0.0.1', function() {
+    var args = ['s_client', '-connect', `127.0.0.1:${this.address().port}`,
+                '-cipher', ciphers];
+
+    // for the performance and stability issue in s_client on Windows
+    if (common.isWindows)
+      args.push('-no_rand_screen');
+
+    var client = spawn(common.opensslCli, args);
+    var out = '';
+    client.stdout.setEncoding('utf8');
+    client.stdout.on('data', function(d) {
+      out += d;
+    });
+    client.stdout.on('end', function() {
+      // DHE key length can be checked -brief option in s_client but it
+      // is only supported in openssl 1.0.2 so we cannot check it.
+      var reg = new RegExp('Cipher    : ' + expectedCipher);
+      if (reg.test(out)) {
+        nsuccess++;
+        server.close();
+      }
+    });
+  });
+}
+
+function test512() {
+  assert.throws(function() {
+    test(512, 'DHE-RSA-AES128-SHA256', null);
+  }, /DH parameter is less than 1024 bits/);
+}
+
+function test1024() {
+  test(1024, 'DHE-RSA-AES128-SHA256', test2048);
+  ntests++;
+}
+
+function test2048() {
+  test(2048, 'DHE-RSA-AES128-SHA256', testError);
+  ntests++;
+}
+
+function testError() {
+  test('error', 'ECDHE-RSA-AES128-SHA256', test512);
+  ntests++;
+}
+
+test1024();
+
+process.on('exit', function() {
+  assert.equal(ntests, nsuccess);
+  assert.equal(ntests, 3);
+});
diff --git a/test/disabled/test-tls-ecdh-disable.js b/test/disabled/test-tls-ecdh-disable.js
new file mode 100644
index 0000000..a6ddb15
--- /dev/null
+++ b/test/disabled/test-tls-ecdh-disable.js
@@ -0,0 +1,37 @@
+'use strict';
+var common = require('../common');
+var assert = require('assert');
+
+if (!common.hasCrypto) {
+  common.skip('missing crypto');
+  return;
+}
+var tls = require('tls');
+
+var exec = require('child_process').exec;
+var fs = require('fs');
+
+var options = {
+  key: fs.readFileSync(common.fixturesDir + '/keys/agent2-key.pem'),
+  cert: fs.readFileSync(common.fixturesDir + '/keys/agent2-cert.pem'),
+  ciphers: 'ECDHE-RSA-RC4-SHA',
+  ecdhCurve: false
+};
+
+var server = tls.createServer(options, common.fail);
+
+server.listen(0, '127.0.0.1', function() {
+  var cmd = '"' + common.opensslCli + '" s_client -cipher ' + options.ciphers +
+            ` -connect 127.0.0.1:${this.address().port}`;
+
+  // for the performance and stability issue in s_client on Windows
+  if (common.isWindows)
+    cmd += ' -no_rand_screen';
+
+  exec(cmd, function(err, stdout, stderr) {
+    // Old versions of openssl will still exit with 0 so we
+    // can't just check if err is not null.
+    assert.notEqual(stderr.indexOf('handshake failure'), -1);
+    server.close();
+  });
+});
diff --git a/test/disabled/test-tls-ecdh.js b/test/disabled/test-tls-ecdh.js
new file mode 100644
index 0000000..e375522
--- /dev/null
+++ b/test/disabled/test-tls-ecdh.js
@@ -0,0 +1,40 @@
+'use strict';
+var common = require('../common');
+var assert = require('assert');
+
+if (!common.hasCrypto) {
+  common.skip('missing crypto');
+  return;
+}
+var tls = require('tls');
+
+var exec = require('child_process').exec;
+var fs = require('fs');
+
+var options = {
+  key: fs.readFileSync(common.fixturesDir + '/keys/agent2-key.pem'),
+  cert: fs.readFileSync(common.fixturesDir + '/keys/agent2-cert.pem'),
+  ciphers: '-ALL:ECDHE-RSA-AES128-SHA256',
+  ecdhCurve: 'prime256v1'
+};
+
+var reply = 'I AM THE WALRUS'; // something recognizable
+
+var server = tls.createServer(options, common.mustCall(function(conn) {
+  conn.end(reply);
+}));
+
+server.listen(0, '127.0.0.1', common.mustCall(function() {
+  var cmd = '"' + common.opensslCli + '" s_client -cipher ' + options.ciphers +
+            ` -connect 127.0.0.1:${this.address().port}`;
+
+  // for the performance and stability issue in s_client on Windows
+  if (common.isWindows)
+    cmd += ' -no_rand_screen';
+
+  exec(cmd, common.mustCall(function(err, stdout, stderr) {
+    if (err) throw err;
+    assert.notEqual(stdout.indexOf(reply), -1);
+    server.close();
+  }));
+}));
diff --git a/test/disabled/test-tls-empty-sni-context.js b/test/disabled/test-tls-empty-sni-context.js
new file mode 100644
index 0000000..52e9f14
--- /dev/null
+++ b/test/disabled/test-tls-empty-sni-context.js
@@ -0,0 +1,43 @@
+'use strict';
+
+const common = require('../common');
+
+if (!process.features.tls_sni) {
+  console.log('1..0 # Skipped: node compiled without OpenSSL or ' +
+              'with old OpenSSL version.');
+  return;
+}
+
+const assert = require('assert');
+
+if (!common.hasCrypto) {
+  console.log('1..0 # Skipped: missing crypto');
+  return;
+}
+
+const tls = require('tls');
+
+const options = {
+  SNICallback: (name, callback) => {
+    callback(null, tls.createSecureContext());
+  }
+};
+
+const server = tls.createServer(options, (c) => {
+  common.fail('Should not be called');
+}).on('tlsClientError', common.mustCall((err, c) => {
+  assert(/SSL_use_certificate:passed a null parameter/i.test(err.message));
+  server.close();
+})).listen(0, common.mustCall(() => {
+  const c = tls.connect({
+    port: server.address().port,
+    rejectUnauthorized: false,
+    servername: 'any.name'
+  }, () => {
+    common.fail('Should not be called');
+  });
+
+  c.on('error', common.mustCall((err) => {
+    assert(/socket hang up/.test(err.message));
+  }));
+}));
diff --git a/test/disabled/test-tls-ocsp-callback.js b/test/disabled/test-tls-ocsp-callback.js
new file mode 100644
index 0000000..442f547
--- /dev/null
+++ b/test/disabled/test-tls-ocsp-callback.js
@@ -0,0 +1,131 @@
+'use strict';
+var common = require('../common');
+
+if (!process.features.tls_ocsp) {
+  common.skip('node compiled without OpenSSL or ' +
+              'with old OpenSSL version.');
+  return;
+}
+if (!common.opensslCli) {
+  common.skip('node compiled without OpenSSL CLI.');
+  return;
+}
+
+if (!common.hasCrypto) {
+  common.skip('missing crypto');
+  return;
+}
+var tls = require('tls');
+
+var assert = require('assert');
+var fs = require('fs');
+var join = require('path').join;
+
+const SSL_OP_NO_TICKET = require('crypto').constants.SSL_OP_NO_TICKET;
+
+var pfx = fs.readFileSync(join(common.fixturesDir, 'keys', 'agent1-pfx.pem'));
+
+function test(testOptions, cb) {
+
+  var keyFile = join(common.fixturesDir, 'keys', 'agent1-key.pem');
+  var certFile = join(common.fixturesDir, 'keys', 'agent1-cert.pem');
+  var caFile = join(common.fixturesDir, 'keys', 'ca1-cert.pem');
+  var key = fs.readFileSync(keyFile);
+  var cert = fs.readFileSync(certFile);
+  var ca = fs.readFileSync(caFile);
+  var options = {
+    key: key,
+    cert: cert,
+    ca: [ca]
+  };
+  var requestCount = 0;
+  var clientSecure = 0;
+  var ocspCount = 0;
+  var ocspResponse;
+
+  if (testOptions.pfx) {
+    delete options.key;
+    delete options.cert;
+    options.pfx = testOptions.pfx;
+    options.passphrase = testOptions.passphrase;
+  }
+
+  var server = tls.createServer(options, function(cleartext) {
+    cleartext.on('error', function(er) {
+      // We're ok with getting ECONNRESET in this test, but it's
+      // timing-dependent, and thus unreliable. Any other errors
+      // are just failures, though.
+      if (er.code !== 'ECONNRESET')
+        throw er;
+    });
+    ++requestCount;
+    cleartext.end();
+  });
+  server.on('OCSPRequest', function(cert, issuer, callback) {
+    ++ocspCount;
+    assert.ok(Buffer.isBuffer(cert));
+    assert.ok(Buffer.isBuffer(issuer));
+
+    // Just to check that async really works there
+    setTimeout(function() {
+      callback(null,
+               testOptions.response ? Buffer.from(testOptions.response) : null);
+    }, 100);
+  });
+  server.listen(0, function() {
+    var client = tls.connect({
+      port: this.address().port,
+      requestOCSP: testOptions.ocsp !== false,
+      secureOptions: testOptions.ocsp === false ?
+          SSL_OP_NO_TICKET : 0,
+      rejectUnauthorized: false
+    }, function() {
+      clientSecure++;
+    });
+    client.on('OCSPResponse', function(resp) {
+      ocspResponse = resp;
+      if (resp)
+        client.destroy();
+    });
+    client.on('close', function() {
+      server.close(cb);
+    });
+  });
+
+  process.on('exit', function() {
+    if (testOptions.ocsp === false) {
+      assert.equal(requestCount, clientSecure);
+      assert.equal(requestCount, 1);
+      return;
+    }
+
+    if (testOptions.response) {
+      assert.equal(ocspResponse.toString(), testOptions.response);
+    } else {
+      assert.ok(ocspResponse === null);
+    }
+    assert.equal(requestCount, testOptions.response ? 0 : 1);
+    assert.equal(clientSecure, requestCount);
+    assert.equal(ocspCount, 1);
+  });
+}
+
+var tests = [
+  { response: false },
+  { response: 'hello world' },
+  { ocsp: false }
+];
+
+if (!common.hasFipsCrypto) {
+  tests.push({ pfx: pfx, passphrase: 'sample', response: 'hello pfx' });
+}
+
+function runTests(i) {
+  if (i === tests.length) return;
+
+  test(tests[i], common.mustCall(function() {
+    runTests(i + 1);
+  }));
+}
+
+runTests(0);
diff --git a/test/disabled/test-tls-pfx-gh-5100-regr.js b/test/disabled/test-tls-pfx-gh-5100-regr.js
new file mode 100644
index 0000000..4670d9e
--- /dev/null
+++ b/test/disabled/test-tls-pfx-gh-5100-regr.js
@@ -0,0 +1,40 @@
+'use strict';
+
+const common = require('../common');
+
+if (!common.hasCrypto) {
+  common.skip('node compiled without crypto.');
+  return;
+}
+
+const assert = require('assert');
+const tls = require('tls');
+const fs = require('fs');
+const path = require('path');
+
+const pfx = fs.readFileSync(
+    path.join(common.fixturesDir, 'keys', 'agent1-pfx.pem'));
+
+const server = tls.createServer({
+  pfx: pfx,
+  passphrase: 'sample',
+  requestCert: true,
+  rejectUnauthorized: false
+}, common.mustCall(function(c) {
+  assert.strictEqual(
+    c.authorizationError,
+    null,
+    'authorizationError must be null'
+  );
+  c.end();
+})).listen(0, function() {
+  var client = tls.connect({
+    port: this.address().port,
+    pfx: pfx,
+    passphrase: 'sample',
+    rejectUnauthorized: false
+  }, function() {
+    client.end();
+    server.close();
+  });
+});
diff --git a/test/disabled/test-tls-securepair-server.js b/test/disabled/test-tls-securepair-server.js
new file mode 100644
index 0000000..24ac217
--- /dev/null
+++ b/test/disabled/test-tls-securepair-server.js
@@ -0,0 +1,133 @@
+'use strict';
+var common = require('../common');
+var assert = require('assert');
+
+if (!common.hasCrypto) {
+  common.skip('missing crypto');
+  return;
+}
+var tls = require('tls');
+
+var join = require('path').join;
+var net = require('net');
+var fs = require('fs');
+var spawn = require('child_process').spawn;
+
+var key = fs.readFileSync(join(common.fixturesDir, 'agent.key')).toString();
+var cert = fs.readFileSync(join(common.fixturesDir, 'agent.crt')).toString();
+
+function log(a) {
+  console.error('***server*** ' + a);
+}
+
+var server = net.createServer(common.mustCall(function(socket) {
+  log('connection fd=' + socket.fd);
+  var sslcontext = tls.createSecureContext({key: key, cert: cert});
+  sslcontext.context.setCiphers('RC4-SHA:AES128-SHA:AES256-SHA');
+
+  var pair = tls.createSecurePair(sslcontext, true);
+
+  assert.ok(pair.encrypted.writable);
+  assert.ok(pair.cleartext.writable);
+
+  pair.encrypted.pipe(socket);
+  socket.pipe(pair.encrypted);
+
+  log('i set it secure');
+
+  pair.on('secure', function() {
+    log('connected+secure!');
+    pair.cleartext.write('hello\r\n');
+    log(pair.cleartext.getPeerCertificate());
+    log(pair.cleartext.getCipher());
+  });
+
+  pair.cleartext.on('data', function(data) {
+    log('read bytes ' + data.length);
+    pair.cleartext.write(data);
+  });
+
+  socket.on('end', function() {
+    log('socket end');
+  });
+
+  pair.cleartext.on('error', function(err) {
+    log('got error: ');
+    log(err);
+    log(err.stack);
+    socket.destroy();
+  });
+
+  pair.encrypted.on('error', function(err) {
+    log('encrypted error: ');
+    log(err);
+    log(err.stack);
+    socket.destroy();
+  });
+
+  socket.on('error', function(err) {
+    log('socket error: ');
+    log(err);
+    log(err.stack);
+    socket.destroy();
+  });
+
+  socket.on('close', function(err) {
+    log('socket closed');
+  });
+
+  pair.on('error', function(err) {
+    log('secure error: ');
+    log(err);
+    log(err.stack);
+    socket.destroy();
+  });
+}));
+
+var gotHello = false;
+var sentWorld = false;
+var gotWorld = false;
+
+server.listen(0, common.mustCall(function() {
+  // To test use: openssl s_client -connect localhost:8000
+
+  var args = ['s_client', '-connect', `127.0.0.1:${this.address().port}`];
+
+  // for the performance and stability issue in s_client on Windows
+  if (common.isWindows)
+    args.push('-no_rand_screen');
+
+  var client = spawn(common.opensslCli, args);
+
+
+  var out = '';
+
+  client.stdout.setEncoding('utf8');
+  client.stdout.on('data', function(d) {
+    out += d;
+
+    if (!gotHello && /hello/.test(out)) {
+      gotHello = true;
+      client.stdin.write('world\r\n');
+      sentWorld = true;
+    }
+
+    if (!gotWorld && /world/.test(out)) {
+      gotWorld = true;
+      client.stdin.end();
+    }
+  });
+
+  client.stdout.pipe(process.stdout, { end: false });
+
+  client.on('exit', common.mustCall(function(code) {
+    assert.strictEqual(0, code);
+    server.close();
+  }));
+}));
+
+process.on('exit', function() {
+  assert.ok(gotHello);
+  assert.ok(sentWorld);
+  assert.ok(gotWorld);
+});
diff --git a/test/disabled/test-tls-sni-option.js b/test/disabled/test-tls-sni-option.js
new file mode 100644
index 0000000..42d6a90
--- /dev/null
+++ b/test/disabled/test-tls-sni-option.js
@@ -0,0 +1,170 @@
+'use strict';
+if (!process.features.tls_sni) {
+  common.skip('node compiled without OpenSSL or ' +
+              'with old OpenSSL version.');
+  return;
+}
+
+const common = require('../common');
+const assert = require('assert');
+const fs = require('fs');
+
+if (!common.hasCrypto) {
+  common.skip('missing crypto');
+  return;
+}
+var tls = require('tls');
+
+function filenamePEM(n) {
+  return require('path').join(common.fixturesDir, 'keys', n + '.pem');
+}
+
+function loadPEM(n) {
+  return fs.readFileSync(filenamePEM(n));
+}
+
+var serverOptions = {
+  key: loadPEM('agent2-key'),
+  cert: loadPEM('agent2-cert'),
+  requestCert: true,
+  rejectUnauthorized: false,
+  SNICallback: function(servername, callback) {
+    var context = SNIContexts[servername];
+
+    // Just to test asynchronous callback
+    setTimeout(function() {
+      if (context) {
+        if (context.emptyRegression)
+          callback(null, {});
+        else
+          callback(null, tls.createSecureContext(context));
+      } else {
+        callback(null, null);
+      }
+    }, 100);
+  }
+};
+
+var SNIContexts = {
+  'a.example.com': {
+    key: loadPEM('agent1-key'),
+    cert: loadPEM('agent1-cert'),
+    ca: [ loadPEM('ca2-cert') ]
+  },
+  'b.example.com': {
+    key: loadPEM('agent3-key'),
+    cert: loadPEM('agent3-cert')
+  },
+  'c.another.com': {
+    emptyRegression: true
+  }
+};
+
+var clientsOptions = [{
+  port: undefined,
+  key: loadPEM('agent1-key'),
+  cert: loadPEM('agent1-cert'),
+  ca: [loadPEM('ca1-cert')],
+  servername: 'a.example.com',
+  rejectUnauthorized: false
+}, {
+  port: undefined,
+  key: loadPEM('agent4-key'),
+  cert: loadPEM('agent4-cert'),
+  ca: [loadPEM('ca1-cert')],
+  servername: 'a.example.com',
+  rejectUnauthorized: false
+}, {
+  port: undefined,
+  key: loadPEM('agent2-key'),
+  cert: loadPEM('agent2-cert'),
+  ca: [loadPEM('ca2-cert')],
+  servername: 'b.example.com',
+  rejectUnauthorized: false
+}, {
+  port: undefined,
+  key: loadPEM('agent3-key'),
+  cert: loadPEM('agent3-cert'),
+  ca: [loadPEM('ca1-cert')],
+  servername: 'c.wrong.com',
+  rejectUnauthorized: false
+}, {
+  port: undefined,
+  key: loadPEM('agent3-key'),
+  cert: loadPEM('agent3-cert'),
+  ca: [loadPEM('ca1-cert')],
+  servername: 'c.another.com',
+  rejectUnauthorized: false
+}];
+
+const serverResults = [];
+const clientResults = [];
+const serverErrors = [];
+const clientErrors = [];
+let serverError;
+let clientError;
+
+var server = tls.createServer(serverOptions, function(c) {
+  serverResults.push({ sni: c.servername, authorized: c.authorized });
+});
+
+server.on('tlsClientError', function(err) {
+  serverResults.push(null);
+  serverError = err.message;
+});
+
+server.listen(0, startTest);
+
+function startTest() {
+  function connectClient(i, callback) {
+    var options = clientsOptions[i];
+    clientError = null;
+    serverError = null;
+
+    options.port = server.address().port;
+    var client = tls.connect(options, function() {
+      clientResults.push(
+          /Hostname\/IP doesn't/.test(client.authorizationError || ''));
+      client.destroy();
+
+      next();
+    });
+
+    client.on('error', function(err) {
+      clientResults.push(false);
+      clientError = err.message;
+      next();
+    });
+
+    function next() {
+      clientErrors.push(clientError);
+      serverErrors.push(serverError);
+
+      if (i === clientsOptions.length - 1)
+        callback();
+      else
+        connectClient(i + 1, callback);
+    }
+  }
+
+  connectClient(0, function() {
+    server.close();
+  });
+}
+
+process.on('exit', function() {
+  assert.deepStrictEqual(serverResults, [
+    { sni: 'a.example.com', authorized: false },
+    { sni: 'a.example.com', authorized: true },
+    { sni: 'b.example.com', authorized: false },
+    { sni: 'c.wrong.com', authorized: false },
+    null
+  ]);
+  assert.deepStrictEqual(clientResults, [true, true, true, false, false]);
+  assert.deepStrictEqual(clientErrors, [
+    null, null, null, null, 'socket hang up'
+  ]);
+  assert.deepStrictEqual(serverErrors, [
+    null, null, null, null, 'Invalid SNI context'
+  ]);
+});
diff --git a/test/disabled/test-tls-sni-server-client.js b/test/disabled/test-tls-sni-server-client.js
new file mode 100644
index 0000000..e743078
--- /dev/null
+++ b/test/disabled/test-tls-sni-server-client.js
@@ -0,0 +1,116 @@
+'use strict';
+if (!process.features.tls_sni) {
+  common.skip('node compiled without OpenSSL or ' +
+              'with old OpenSSL version.');
+  return;
+}
+
+const common = require('../common');
+const assert = require('assert');
+const fs = require('fs');
+
+if (!common.hasCrypto) {
+  common.skip('missing crypto');
+  return;
+}
+var tls = require('tls');
+
+function filenamePEM(n) {
+  return require('path').join(common.fixturesDir, 'keys', n + '.pem');
+}
+
+function loadPEM(n) {
+  return fs.readFileSync(filenamePEM(n));
+}
+
+var serverOptions = {
+  key: loadPEM('agent2-key'),
+  cert: loadPEM('agent2-cert')
+};
+
+var SNIContexts = {
+  'a.example.com': {
+    key: loadPEM('agent1-key'),
+    cert: loadPEM('agent1-cert')
+  },
+  'asterisk.test.com': {
+    key: loadPEM('agent3-key'),
+    cert: loadPEM('agent3-cert')
+  },
+  'chain.example.com': {
+    key: loadPEM('agent6-key'),
+    // NOTE: Contains ca3 chain cert
+    cert: loadPEM('agent6-cert')
+  }
+};
+
+var clientsOptions = [{
+  port: undefined,
+  ca: [loadPEM('ca1-cert')],
+  servername: 'a.example.com',
+  rejectUnauthorized: false
+}, {
+  port: undefined,
+  ca: [loadPEM('ca2-cert')],
+  servername: 'b.test.com',
+  rejectUnauthorized: false
+}, {
+  port: undefined,
+  ca: [loadPEM('ca2-cert')],
+  servername: 'a.b.test.com',
+  rejectUnauthorized: false
+}, {
+  port: undefined,
+  ca: [loadPEM('ca1-cert')],
+  servername: 'c.wrong.com',
+  rejectUnauthorized: false
+}, {
+  port: undefined,
+  ca: [loadPEM('ca1-cert')],
+  servername: 'chain.example.com',
+  rejectUnauthorized: false
+}];
+
+const serverResults = [];
+const clientResults = [];
+
+var server = tls.createServer(serverOptions, function(c) {
+  serverResults.push(c.servername);
+});
+
+server.addContext('a.example.com', SNIContexts['a.example.com']);
+server.addContext('*.test.com', SNIContexts['asterisk.test.com']);
+server.addContext('chain.example.com', SNIContexts['chain.example.com']);
+
+server.listen(0, startTest);
+
+function startTest() {
+  var i = 0;
+  function start() {
+    // No options left
+    if (i === clientsOptions.length)
+      return server.close();
+
+    var options = clientsOptions[i++];
+    options.port = server.address().port;
+    var client = tls.connect(options, function() {
+      clientResults.push(
+        client.authorizationError &&
+        /Hostname\/IP doesn't/.test(client.authorizationError));
+      client.destroy();
+
+      // Continue
+      start();
+    });
+  }
+
+  start();
+}
+
+process.on('exit', function() {
+  assert.deepStrictEqual(serverResults, [
+    'a.example.com', 'b.test.com', 'a.b.test.com', 'c.wrong.com',
+    'chain.example.com'
+  ]);
+  assert.deepStrictEqual(clientResults, [true, true, false, false, true]);
+});
diff --git a/test/parallel/test-crypto-dh.js b/test/parallel/test-crypto-dh.js
deleted file mode 100644
index 6a067be..0000000
--- a/test/parallel/test-crypto-dh.js
+++ /dev/null
@@ -1,264 +0,0 @@
-'use strict';
-const common = require('../common');
-const assert = require('assert');
-
-if (!common.hasCrypto) {
-  common.skip('missing crypto');
-  return;
-}
-const crypto = require('crypto');
-const DH_NOT_SUITABLE_GENERATOR = crypto.constants.DH_NOT_SUITABLE_GENERATOR;
-
-// Test Diffie-Hellman with two parties sharing a secret,
-// using various encodings as we go along
-var dh1 = crypto.createDiffieHellman(common.hasFipsCrypto ? 1024 : 256);
-var p1 = dh1.getPrime('buffer');
-var dh2 = crypto.createDiffieHellman(p1, 'buffer');
-var key1 = dh1.generateKeys();
-var key2 = dh2.generateKeys('hex');
-var secret1 = dh1.computeSecret(key2, 'hex', 'base64');
-var secret2 = dh2.computeSecret(key1, 'latin1', 'buffer');
-
-assert.equal(secret1, secret2.toString('base64'));
-assert.equal(dh1.verifyError, 0);
-assert.equal(dh2.verifyError, 0);
-
-assert.throws(function() {
-  crypto.createDiffieHellman([0x1, 0x2]);
-});
-
-assert.throws(function() {
-  crypto.createDiffieHellman(function() { });
-});
-
-assert.throws(function() {
-  crypto.createDiffieHellman(/abc/);
-});
-
-assert.throws(function() {
-  crypto.createDiffieHellman({});
-});
-
-// Create "another dh1" using generated keys from dh1,
-// and compute secret again
-var dh3 = crypto.createDiffieHellman(p1, 'buffer');
-var privkey1 = dh1.getPrivateKey();
-dh3.setPublicKey(key1);
-dh3.setPrivateKey(privkey1);
-
-assert.deepStrictEqual(dh1.getPrime(), dh3.getPrime());
-assert.deepStrictEqual(dh1.getGenerator(), dh3.getGenerator());
-assert.deepStrictEqual(dh1.getPublicKey(), dh3.getPublicKey());
-assert.deepStrictEqual(dh1.getPrivateKey(), dh3.getPrivateKey());
-assert.equal(dh3.verifyError, 0);
-
-var secret3 = dh3.computeSecret(key2, 'hex', 'base64');
-
-assert.equal(secret1, secret3);
-
-// Run this one twice to make sure that the dh3 clears its error properly
-{
-  const c = crypto.createDecipheriv('aes-128-ecb', crypto.randomBytes(16), '');
-  assert.throws(function() { c.final('utf8'); }, /wrong final block length/);
-}
-
-assert.throws(function() {
-  dh3.computeSecret('');
-}, /key is too small/i);
-
-{
-  const c = crypto.createDecipheriv('aes-128-ecb', crypto.randomBytes(16), '');
-  assert.throws(function() { c.final('utf8'); }, /wrong final block length/);
-}
-
-// Create a shared using a DH group.
-var alice = crypto.createDiffieHellmanGroup('modp5');
-var bob = crypto.createDiffieHellmanGroup('modp5');
-alice.generateKeys();
-bob.generateKeys();
-var aSecret = alice.computeSecret(bob.getPublicKey()).toString('hex');
-var bSecret = bob.computeSecret(alice.getPublicKey()).toString('hex');
-assert.equal(aSecret, bSecret);
-assert.equal(alice.verifyError, DH_NOT_SUITABLE_GENERATOR);
-assert.equal(bob.verifyError, DH_NOT_SUITABLE_GENERATOR);
-
-/* Ensure specific generator (buffer) works as expected.
- * The values below (modp2/modp2buf) are for a 1024 bits long prime from
- * RFC 2412 E.2, see https://tools.ietf.org/html/rfc2412. */
-var modp2 = crypto.createDiffieHellmanGroup('modp2');
-var modp2buf = Buffer.from([
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc9, 0x0f,
-  0xda, 0xa2, 0x21, 0x68, 0xc2, 0x34, 0xc4, 0xc6, 0x62, 0x8b,
-  0x80, 0xdc, 0x1c, 0xd1, 0x29, 0x02, 0x4e, 0x08, 0x8a, 0x67,
-  0xcc, 0x74, 0x02, 0x0b, 0xbe, 0xa6, 0x3b, 0x13, 0x9b, 0x22,
-  0x51, 0x4a, 0x08, 0x79, 0x8e, 0x34, 0x04, 0xdd, 0xef, 0x95,
-  0x19, 0xb3, 0xcd, 0x3a, 0x43, 0x1b, 0x30, 0x2b, 0x0a, 0x6d,
-  0xf2, 0x5f, 0x14, 0x37, 0x4f, 0xe1, 0x35, 0x6d, 0x6d, 0x51,
-  0xc2, 0x45, 0xe4, 0x85, 0xb5, 0x76, 0x62, 0x5e, 0x7e, 0xc6,
-  0xf4, 0x4c, 0x42, 0xe9, 0xa6, 0x37, 0xed, 0x6b, 0x0b, 0xff,
-  0x5c, 0xb6, 0xf4, 0x06, 0xb7, 0xed, 0xee, 0x38, 0x6b, 0xfb,
-  0x5a, 0x89, 0x9f, 0xa5, 0xae, 0x9f, 0x24, 0x11, 0x7c, 0x4b,
-  0x1f, 0xe6, 0x49, 0x28, 0x66, 0x51, 0xec, 0xe6, 0x53, 0x81,
-  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
-]);
-var exmodp2 = crypto.createDiffieHellman(modp2buf, Buffer.from([2]));
-modp2.generateKeys();
-exmodp2.generateKeys();
-var modp2Secret = modp2.computeSecret(exmodp2.getPublicKey()).toString('hex');
-var exmodp2Secret = exmodp2.computeSecret(modp2.getPublicKey()).toString('hex');
-assert.equal(modp2Secret, exmodp2Secret);
-assert.equal(modp2.verifyError, DH_NOT_SUITABLE_GENERATOR);
-assert.equal(exmodp2.verifyError, DH_NOT_SUITABLE_GENERATOR);
-
-
-// Ensure specific generator (string with encoding) works as expected.
-var exmodp2_2 = crypto.createDiffieHellman(modp2buf, '02', 'hex');
-exmodp2_2.generateKeys();
-modp2Secret = modp2.computeSecret(exmodp2_2.getPublicKey()).toString('hex');
-var exmodp2_2Secret = exmodp2_2.computeSecret(modp2.getPublicKey())
-                               .toString('hex');
-assert.equal(modp2Secret, exmodp2_2Secret);
-assert.equal(exmodp2_2.verifyError, DH_NOT_SUITABLE_GENERATOR);
-
-
-// Ensure specific generator (string without encoding) works as expected.
-var exmodp2_3 = crypto.createDiffieHellman(modp2buf, '\x02');
-exmodp2_3.generateKeys();
-modp2Secret = modp2.computeSecret(exmodp2_3.getPublicKey()).toString('hex');
-var exmodp2_3Secret = exmodp2_3.computeSecret(modp2.getPublicKey())
-                               .toString('hex');
-assert.equal(modp2Secret, exmodp2_3Secret);
-assert.equal(exmodp2_3.verifyError, DH_NOT_SUITABLE_GENERATOR);
-
-
-// Ensure specific generator (numeric) works as expected.
-var exmodp2_4 = crypto.createDiffieHellman(modp2buf, 2);
-exmodp2_4.generateKeys();
-modp2Secret = modp2.computeSecret(exmodp2_4.getPublicKey()).toString('hex');
-var exmodp2_4Secret = exmodp2_4.computeSecret(modp2.getPublicKey())
-                               .toString('hex');
-assert.equal(modp2Secret, exmodp2_4Secret);
-assert.equal(exmodp2_4.verifyError, DH_NOT_SUITABLE_GENERATOR);
-
-
-var p = 'FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74' +
-        '020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F1437' +
-        '4FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED' +
-        'EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381FFFFFFFFFFFFFFFF';
-var bad_dh = crypto.createDiffieHellman(p, 'hex');
-assert.equal(bad_dh.verifyError, DH_NOT_SUITABLE_GENERATOR);
-
-
-// Test ECDH
-const ecdh1 = crypto.createECDH('prime256v1');
-const ecdh2 = crypto.createECDH('prime256v1');
-key1 = ecdh1.generateKeys();
-key2 = ecdh2.generateKeys('hex');
-secret1 = ecdh1.computeSecret(key2, 'hex', 'base64');
-secret2 = ecdh2.computeSecret(key1, 'latin1', 'buffer');
-
-assert.equal(secret1, secret2.toString('base64'));
-
-// Oakley curves do not clean up ERR stack, it was causing unexpected failure
-// when accessing other OpenSSL APIs afterwards.
-crypto.createECDH('Oakley-EC2N-3');
-crypto.createHash('sha256');
-
-// Point formats
-assert.equal(ecdh1.getPublicKey('buffer', 'uncompressed')[0], 4);
-let firstByte = ecdh1.getPublicKey('buffer', 'compressed')[0];
-assert(firstByte === 2 || firstByte === 3);
-firstByte = ecdh1.getPublicKey('buffer', 'hybrid')[0];
-assert(firstByte === 6 || firstByte === 7);
-
-// ECDH should check that point is on curve
-const ecdh3 = crypto.createECDH('secp256k1');
-const key3 = ecdh3.generateKeys();
-
-assert.throws(function() {
-  ecdh2.computeSecret(key3, 'latin1', 'buffer');
-});
-
-// ECDH should allow .setPrivateKey()/.setPublicKey()
-const ecdh4 = crypto.createECDH('prime256v1');
-
-ecdh4.setPrivateKey(ecdh1.getPrivateKey());
-ecdh4.setPublicKey(ecdh1.getPublicKey());
-
-assert.throws(function() {
-  ecdh4.setPublicKey(ecdh3.getPublicKey());
-}, /Failed to convert Buffer to EC_POINT/);
-
-// Verify that we can use ECDH without having to use newly generated keys.
-const ecdh5 = crypto.createECDH('secp256k1');
-
-// Verify errors are thrown when retrieving keys from an uninitialized object.
-assert.throws(function() {
-  ecdh5.getPublicKey();
-}, /Failed to get ECDH public key/);
-assert.throws(function() {
-  ecdh5.getPrivateKey();
-}, /Failed to get ECDH private key/);
-
-// A valid private key for the secp256k1 curve.
-const cafebabeKey = 'cafebabe'.repeat(8);
-// Associated compressed and uncompressed public keys (points).
-const cafebabePubPtComp =
-'03672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3';
-const cafebabePubPtUnComp =
-'04672a31bfc59d3f04548ec9b7daeeba2f61814e8ccc40448045007f5479f693a3' +
-'2e02c7f93d13dc2732b760ca377a5897b9dd41a1c1b29dc0442fdce6d0a04d1d';
-ecdh5.setPrivateKey(cafebabeKey, 'hex');
-assert.equal(ecdh5.getPrivateKey('hex'), cafebabeKey);
-// Show that the public point (key) is generated while setting the private key.
-assert.equal(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
-
-// Compressed and uncompressed public points/keys for other party's private key
-// 0xDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEFDEADBEEF
-const peerPubPtComp =
-'02c6b754b20826eb925e052ee2c25285b162b51fdca732bcf67e39d647fb6830ae';
-const peerPubPtUnComp =
-'04c6b754b20826eb925e052ee2c25285b162b51fdca732bcf67e39d647fb6830ae' +
-'b651944a574a362082a77e3f2b5d9223eb54d7f2f76846522bf75f3bedb8178e';
-
-const sharedSecret =
-'1da220b5329bbe8bfd19ceef5a5898593f411a6f12ea40f2a8eead9a5cf59970';
-
-assert.equal(ecdh5.computeSecret(peerPubPtComp, 'hex', 'hex'), sharedSecret);
-assert.equal(ecdh5.computeSecret(peerPubPtUnComp, 'hex', 'hex'), sharedSecret);
-
-// Verify that we still have the same key pair as before the computation.
-assert.equal(ecdh5.getPrivateKey('hex'), cafebabeKey);
-assert.equal(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
-
-// Verify setting and getting compressed and non-compressed serializations.
-ecdh5.setPublicKey(cafebabePubPtComp, 'hex');
-assert.equal(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
-assert.equal(ecdh5.getPublicKey('hex', 'compressed'), cafebabePubPtComp);
-ecdh5.setPublicKey(cafebabePubPtUnComp, 'hex');
-assert.equal(ecdh5.getPublicKey('hex'), cafebabePubPtUnComp);
-assert.equal(ecdh5.getPublicKey('hex', 'compressed'), cafebabePubPtComp);
-
-// Show why allowing the public key to be set on this type does not make sense.
-ecdh5.setPublicKey(peerPubPtComp, 'hex');
-assert.equal(ecdh5.getPublicKey('hex'), peerPubPtUnComp);
-assert.throws(function() {
-  // Error because the public key does not match the private key anymore.
-  ecdh5.computeSecret(peerPubPtComp, 'hex', 'hex');
-}, /Invalid key pair/);
-
-// Set to a valid key to show that later attempts to set an invalid key are
-// rejected.
-ecdh5.setPrivateKey(cafebabeKey, 'hex');
-
-[ // Some invalid private keys for the secp256k1 curve.
-  '0000000000000000000000000000000000000000000000000000000000000000',
-  'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141',
-  'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF',
-].forEach(function(element, index, object) {
-  assert.throws(function() {
-    ecdh5.setPrivateKey(element, 'hex');
-  }, /Private key is not valid for specified curve/);
-  // Verify object state did not change.
-  assert.equal(ecdh5.getPrivateKey('hex'), cafebabeKey);
-});
diff --git a/test/parallel/test-crypto-fips.js b/test/parallel/test-crypto-fips.js
deleted file mode 100644
index 55b542c..0000000
--- a/test/parallel/test-crypto-fips.js
+++ /dev/null
@@ -1,201 +0,0 @@
-'use strict';
-var common = require('../common');
-var assert = require('assert');
-var spawnSync = require('child_process').spawnSync;
-var path = require('path');
-
-if (!common.hasCrypto) {
-  common.skip('missing crypto');
-  return;
-}
-
-const FIPS_ENABLED = 1;
-const FIPS_DISABLED = 0;
-const FIPS_ERROR_STRING = 'Error: Cannot set FIPS mode';
-const OPTION_ERROR_STRING = 'bad option';
-const CNF_FIPS_ON = path.join(common.fixturesDir, 'openssl_fips_enabled.cnf');
-const CNF_FIPS_OFF = path.join(common.fixturesDir, 'openssl_fips_disabled.cnf');
-var num_children_ok = 0;
-
-function compiledWithFips() {
-  return process.config.variables.openssl_fips ? true : false;
-}
-
-function addToEnv(newVar, value) {
-  var envCopy = {};
-  for (const e in process.env) {
-    envCopy[e] = process.env[e];
-  }
-  envCopy[newVar] = value;
-  return envCopy;
-}
-
-function testHelper(stream, args, expectedOutput, cmd, env) {
-  const fullArgs = args.concat(['-e', 'console.log(' + cmd + ')']);
-  const child = spawnSync(process.execPath, fullArgs, {
-    cwd: path.dirname(process.execPath),
-    env: env
-  });
-
-  console.error('Spawned child [pid:' + child.pid + '] with cmd ' +
-      cmd + ' and args \'' + args + '\'');
-
-  function childOk(child) {
-    console.error('Child #' + ++num_children_ok +
-        ' [pid:' + child.pid + '] OK.');
-  }
-
-  function responseHandler(buffer, expectedOutput) {
-    const response = buffer.toString();
-    assert.notEqual(0, response.length);
-    if (FIPS_ENABLED !== expectedOutput && FIPS_DISABLED !== expectedOutput) {
-      // In the case of expected errors just look for a substring.
-      assert.notEqual(-1, response.indexOf(expectedOutput));
-    } else {
-      // Normal path where we expect either FIPS enabled or disabled.
-      assert.equal(expectedOutput, response);
-    }
-    childOk(child);
-  }
-
-  responseHandler(child[stream], expectedOutput);
-}
-
-// By default FIPS should be off in both FIPS and non-FIPS builds.
-testHelper(
-  'stdout',
-  [],
-  FIPS_DISABLED,
-  'require("crypto").fips',
-  addToEnv('OPENSSL_CONF', ''));
-
-// --enable-fips should turn FIPS mode on
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  ['--enable-fips'],
-  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
-  'require("crypto").fips',
-  process.env);
-
-//--force-fips should turn FIPS mode on
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  ['--force-fips'],
-  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
-  'require("crypto").fips',
-  process.env);
-
-// OpenSSL config file should be able to turn on FIPS mode
-testHelper(
-  'stdout',
-  [`--openssl-config=${CNF_FIPS_ON}`],
-  compiledWithFips() ? FIPS_ENABLED : FIPS_DISABLED,
-  'require("crypto").fips',
-  process.env);
-// OPENSSL_CONF should _not_ be able to turn on FIPS mode
-testHelper(
-  'stdout',
-  [],
-  FIPS_DISABLED,
-  'require("crypto").fips',
-  addToEnv('OPENSSL_CONF', CNF_FIPS_ON));
-
-// --enable-fips should take precedence over OpenSSL config file
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  ['--enable-fips', `--openssl-config=${CNF_FIPS_OFF}`],
-  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
-  'require("crypto").fips',
-  process.env);
-// OPENSSL_CONF should _not_ make a difference to --enable-fips
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  ['--enable-fips'],
-  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
-  'require("crypto").fips',
-  addToEnv('OPENSSL_CONF', CNF_FIPS_OFF));
-
-// --force-fips should take precedence over OpenSSL config file
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  ['--force-fips', `--openssl-config=${CNF_FIPS_OFF}`],
-  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
-  'require("crypto").fips',
-  process.env);
-// Using OPENSSL_CONF should not make a difference to --force-fips
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  ['--force-fips'],
-  compiledWithFips() ? FIPS_ENABLED : OPTION_ERROR_STRING,
-  'require("crypto").fips',
-  addToEnv('OPENSSL_CONF', CNF_FIPS_OFF));
-
-// setFipsCrypto should be able to turn FIPS mode on
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  [],
-  compiledWithFips() ? FIPS_ENABLED : FIPS_ERROR_STRING,
-  '(require("crypto").fips = true,' +
-  'require("crypto").fips)',
-  process.env);
-
-// setFipsCrypto should be able to turn FIPS mode on and off
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  [],
-  compiledWithFips() ? FIPS_DISABLED : FIPS_ERROR_STRING,
-  '(require("crypto").fips = true,' +
-  'require("crypto").fips = false,' +
-  'require("crypto").fips)',
-  process.env);
-
-// setFipsCrypto takes precedence over OpenSSL config file, FIPS on
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  [`--openssl-config=${CNF_FIPS_OFF}`],
-  compiledWithFips() ? FIPS_ENABLED : FIPS_ERROR_STRING,
-  '(require("crypto").fips = true,' +
-  'require("crypto").fips)',
-  process.env);
-
-// setFipsCrypto takes precedence over OpenSSL config file, FIPS off
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  [`--openssl-config=${CNF_FIPS_ON}`],
-  compiledWithFips() ? FIPS_DISABLED : FIPS_ERROR_STRING,
-  '(require("crypto").fips = false,' +
-  'require("crypto").fips)',
-  process.env);
-
-// --enable-fips does not prevent use of setFipsCrypto API
-testHelper(
-  compiledWithFips() ? 'stdout' : 'stderr',
-  ['--enable-fips'],
-  compiledWithFips() ? FIPS_DISABLED : OPTION_ERROR_STRING,
-  '(require("crypto").fips = false,' +
-  'require("crypto").fips)',
-  process.env);
-
-// --force-fips prevents use of setFipsCrypto API
-testHelper(
-  'stderr',
-  ['--force-fips'],
-  compiledWithFips() ? FIPS_ERROR_STRING : OPTION_ERROR_STRING,
-  'require("crypto").fips = false',
-  process.env);
-
-// --force-fips and --enable-fips order does not matter
-testHelper(
-  'stderr',
-  ['--force-fips', '--enable-fips'],
-  compiledWithFips() ? FIPS_ERROR_STRING : OPTION_ERROR_STRING,
-  'require("crypto").fips = false',
-  process.env);
-
-//--enable-fips and --force-fips order does not matter
-testHelper(
-  'stderr',
-  ['--enable-fips', '--force-fips'],
-  compiledWithFips() ? FIPS_ERROR_STRING : OPTION_ERROR_STRING,
-  'require("crypto").fips = false',
-  process.env);
diff --git a/test/parallel/test-tls-cnnic-whitelist.js b/test/parallel/test-tls-cnnic-whitelist.js
deleted file mode 100644
index f16698c..0000000
--- a/test/parallel/test-tls-cnnic-whitelist.js
+++ /dev/null
@@ -1,84 +0,0 @@
-'use strict';
-var common = require('../common');
-var assert = require('assert');
-
-if (!common.hasCrypto) {
-  common.skip('missing crypto');
-  return;
-}
-
-var tls = require('tls');
-var fs = require('fs');
-var path = require('path');
-var finished = 0;
-
-function filenamePEM(n) {
-  return path.join(common.fixturesDir, 'keys', n + '.pem');
-}
-
-function loadPEM(n) {
-  return fs.readFileSync(filenamePEM(n));
-}
-
-var testCases = [
-  { // Test 0: for the check of a cert not existed in the whitelist.
-    // agent7-cert.pem is issued by the fake CNNIC root CA so that its
-    // hash is not listed in the whitelist.
-    // fake-cnnic-root-cert has the same subject name as the original
-    // rootCA.
-    serverOpts: {
-      key: loadPEM('agent7-key'),
-      cert: loadPEM('agent7-cert')
-    },
-    clientOpts: {
-      port: undefined,
-      rejectUnauthorized: true,
-      ca: [loadPEM('fake-cnnic-root-cert')]
-    },
-    errorCode: 'CERT_REVOKED'
-  },
-  // Test 1: for the fix of node#2061
-  // agent6-cert.pem is signed by intermidate cert of ca3.
-  // The server has a cert chain of agent6->ca3->ca1(root) but
-  // tls.connect should be failed with an error of
-  // UNABLE_TO_GET_ISSUER_CERT_LOCALLY since the root CA of ca1 is not
-  // installed locally.
-  {
-    serverOpts: {
-      ca: loadPEM('ca3-key'),
-      key: loadPEM('agent6-key'),
-      cert: loadPEM('agent6-cert')
-    },
-    clientOpts: {
-      port: undefined,
-      rejectUnauthorized: true
-    },
-    errorCode: 'UNABLE_TO_GET_ISSUER_CERT_LOCALLY'
-  }
-];
-
-function runTest(tindex) {
-  var tcase = testCases[tindex];
-
-  if (!tcase) return;
-
-  var server = tls.createServer(tcase.serverOpts, function(s) {
-    s.resume();
-  }).listen(0, function() {
-    tcase.clientOpts = this.address().port;
-    var client = tls.connect(tcase.clientOpts);
-    client.on('error', function(e) {
-      assert.strictEqual(e.code, tcase.errorCode);
-      server.close(function() {
-        finished++;
-        runTest(tindex + 1);
-      });
-    });
-  });
-}
-
-runTest(0);
-
-process.on('exit', function() {
-  assert.equal(finished, testCases.length);
-});
diff --git a/test/parallel/test-tls-dhe.js b/test/parallel/test-tls-dhe.js
deleted file mode 100644
index 92ab415..0000000
--- a/test/parallel/test-tls-dhe.js
+++ /dev/null
@@ -1,95 +0,0 @@
-'use strict';
-var common = require('../common');
-var assert = require('assert');
-
-if (!common.hasCrypto) {
-  common.skip('missing crypto');
-  return;
-}
-var tls = require('tls');
-
-var spawn = require('child_process').spawn;
-var fs = require('fs');
-var key = fs.readFileSync(common.fixturesDir + '/keys/agent2-key.pem');
-var cert = fs.readFileSync(common.fixturesDir + '/keys/agent2-cert.pem');
-var nsuccess = 0;
-var ntests = 0;
-var ciphers = 'DHE-RSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';
-
-
-function loadDHParam(n) {
-  var path = common.fixturesDir;
-  if (n !== 'error') path += '/keys';
-  return fs.readFileSync(path + '/dh' + n + '.pem');
-}
-
-function test(keylen, expectedCipher, cb) {
-  var options = {
-    key: key,
-    cert: cert,
-    ciphers: ciphers,
-    dhparam: loadDHParam(keylen)
-  };
-
-  var server = tls.createServer(options, function(conn) {
-    conn.end();
-  });
-
-  server.on('close', function(err) {
-    assert(!err);
-    if (cb) cb();
-  });
-
-  server.listen(0, '127.0.0.1', function() {
-    var args = ['s_client', '-connect', `127.0.0.1:${this.address().port}`,
-                '-cipher', ciphers];
-
-    // for the performance and stability issue in s_client on Windows
-    if (common.isWindows)
-      args.push('-no_rand_screen');
-
-    var client = spawn(common.opensslCli, args);
-    var out = '';
-    client.stdout.setEncoding('utf8');
-    client.stdout.on('data', function(d) {
-      out += d;
-    });
-    client.stdout.on('end', function() {
-      // DHE key length can be checked -brief option in s_client but it
-      // is only supported in openssl 1.0.2 so we cannot check it.
-      var reg = new RegExp('Cipher    : ' + expectedCipher);
-      if (reg.test(out)) {
-        nsuccess++;
-        server.close();
-      }
-    });
-  });
-}
-
-function test512() {
-  assert.throws(function() {
-    test(512, 'DHE-RSA-AES128-SHA256', null);
-  }, /DH parameter is less than 1024 bits/);
-}
-
-function test1024() {
-  test(1024, 'DHE-RSA-AES128-SHA256', test2048);
-  ntests++;
-}
-
-function test2048() {
-  test(2048, 'DHE-RSA-AES128-SHA256', testError);
-  ntests++;
-}
-
-function testError() {
-  test('error', 'ECDHE-RSA-AES128-SHA256', test512);
-  ntests++;
-}
-
-test1024();
-
-process.on('exit', function() {
-  assert.equal(ntests, nsuccess);
-  assert.equal(ntests, 3);
-});
diff --git a/test/parallel/test-tls-ecdh-disable.js b/test/parallel/test-tls-ecdh-disable.js
deleted file mode 100644
index a6ddb15..0000000
--- a/test/parallel/test-tls-ecdh-disable.js
+++ /dev/null
@@ -1,37 +0,0 @@
-'use strict';
-var common = require('../common');
-var assert = require('assert');
-
-if (!common.hasCrypto) {
-  common.skip('missing crypto');
-  return;
-}
-var tls = require('tls');
-
-var exec = require('child_process').exec;
-var fs = require('fs');
-
-var options = {
-  key: fs.readFileSync(common.fixturesDir + '/keys/agent2-key.pem'),
-  cert: fs.readFileSync(common.fixturesDir + '/keys/agent2-cert.pem'),
-  ciphers: 'ECDHE-RSA-RC4-SHA',
-  ecdhCurve: false
-};
-
-var server = tls.createServer(options, common.fail);
-
-server.listen(0, '127.0.0.1', function() {
-  var cmd = '"' + common.opensslCli + '" s_client -cipher ' + options.ciphers +
-            ` -connect 127.0.0.1:${this.address().port}`;
-
-  // for the performance and stability issue in s_client on Windows
-  if (common.isWindows)
-    cmd += ' -no_rand_screen';
-
-  exec(cmd, function(err, stdout, stderr) {
-    // Old versions of openssl will still exit with 0 so we
-    // can't just check if err is not null.
-    assert.notEqual(stderr.indexOf('handshake failure'), -1);
-    server.close();
-  });
-});
diff --git a/test/parallel/test-tls-ecdh.js b/test/parallel/test-tls-ecdh.js
deleted file mode 100644
index e375522..0000000
--- a/test/parallel/test-tls-ecdh.js
+++ /dev/null
@@ -1,40 +0,0 @@
-'use strict';
-var common = require('../common');
-var assert = require('assert');
-
-if (!common.hasCrypto) {
-  common.skip('missing crypto');
-  return;
-}
-var tls = require('tls');
-
-var exec = require('child_process').exec;
-var fs = require('fs');
-
-var options = {
-  key: fs.readFileSync(common.fixturesDir + '/keys/agent2-key.pem'),
-  cert: fs.readFileSync(common.fixturesDir + '/keys/agent2-cert.pem'),
-  ciphers: '-ALL:ECDHE-RSA-AES128-SHA256',
-  ecdhCurve: 'prime256v1'
-};
-
-var reply = 'I AM THE WALRUS'; // something recognizable
-
-var server = tls.createServer(options, common.mustCall(function(conn) {
-  conn.end(reply);
-}));
-
-server.listen(0, '127.0.0.1', common.mustCall(function() {
-  var cmd = '"' + common.opensslCli + '" s_client -cipher ' + options.ciphers +
-            ` -connect 127.0.0.1:${this.address().port}`;
-
-  // for the performance and stability issue in s_client on Windows
-  if (common.isWindows)
-    cmd += ' -no_rand_screen';
-
-  exec(cmd, common.mustCall(function(err, stdout, stderr) {
-    if (err) throw err;
-    assert.notEqual(stdout.indexOf(reply), -1);
-    server.close();
-  }));
-}));
diff --git a/test/parallel/test-tls-empty-sni-context.js b/test/parallel/test-tls-empty-sni-context.js
deleted file mode 100644
index 52e9f14..0000000
--- a/test/parallel/test-tls-empty-sni-context.js
+++ /dev/null
@@ -1,43 +0,0 @@
-'use strict';
-
-const common = require('../common');
-
-if (!process.features.tls_sni) {
-  console.log('1..0 # Skipped: node compiled without OpenSSL or ' +
-              'with old OpenSSL version.');
-  return;
-}
-
-const assert = require('assert');
-
-if (!common.hasCrypto) {
-  console.log('1..0 # Skipped: missing crypto');
-  return;
-}
-
-const tls = require('tls');
-
-const options = {
-  SNICallback: (name, callback) => {
-    callback(null, tls.createSecureContext());
-  }
-};
-
-const server = tls.createServer(options, (c) => {
-  common.fail('Should not be called');
-}).on('tlsClientError', common.mustCall((err, c) => {
-  assert(/SSL_use_certificate:passed a null parameter/i.test(err.message));
-  server.close();
-})).listen(0, common.mustCall(() => {
-  const c = tls.connect({
-    port: server.address().port,
-    rejectUnauthorized: false,
-    servername: 'any.name'
-  }, () => {
-    common.fail('Should not be called');
-  });
-
-  c.on('error', common.mustCall((err) => {
-    assert(/socket hang up/.test(err.message));
-  }));
-}));
diff --git a/test/parallel/test-tls-ocsp-callback.js b/test/parallel/test-tls-ocsp-callback.js
deleted file mode 100644
index 442f547..0000000
--- a/test/parallel/test-tls-ocsp-callback.js
+++ /dev/null
@@ -1,131 +0,0 @@
-'use strict';
-var common = require('../common');
-
-if (!process.features.tls_ocsp) {
-  common.skip('node compiled without OpenSSL or ' +
-              'with old OpenSSL version.');
-  return;
-}
-if (!common.opensslCli) {
-  common.skip('node compiled without OpenSSL CLI.');
-  return;
-}
-
-if (!common.hasCrypto) {
-  common.skip('missing crypto');
-  return;
-}
-var tls = require('tls');
-
-var assert = require('assert');
-var fs = require('fs');
-var join = require('path').join;
-
-const SSL_OP_NO_TICKET = require('crypto').constants.SSL_OP_NO_TICKET;
-
-var pfx = fs.readFileSync(join(common.fixturesDir, 'keys', 'agent1-pfx.pem'));
-
-function test(testOptions, cb) {
-
-  var keyFile = join(common.fixturesDir, 'keys', 'agent1-key.pem');
-  var certFile = join(common.fixturesDir, 'keys', 'agent1-cert.pem');
-  var caFile = join(common.fixturesDir, 'keys', 'ca1-cert.pem');
-  var key = fs.readFileSync(keyFile);
-  var cert = fs.readFileSync(certFile);
-  var ca = fs.readFileSync(caFile);
-  var options = {
-    key: key,
-    cert: cert,
-    ca: [ca]
-  };
-  var requestCount = 0;
-  var clientSecure = 0;
-  var ocspCount = 0;
-  var ocspResponse;
-
-  if (testOptions.pfx) {
-    delete options.key;
-    delete options.cert;
-    options.pfx = testOptions.pfx;
-    options.passphrase = testOptions.passphrase;
-  }
-
-  var server = tls.createServer(options, function(cleartext) {
-    cleartext.on('error', function(er) {
-      // We're ok with getting ECONNRESET in this test, but it's
-      // timing-dependent, and thus unreliable. Any other errors
-      // are just failures, though.
-      if (er.code !== 'ECONNRESET')
-        throw er;
-    });
-    ++requestCount;
-    cleartext.end();
-  });
-  server.on('OCSPRequest', function(cert, issuer, callback) {
-    ++ocspCount;
-    assert.ok(Buffer.isBuffer(cert));
-    assert.ok(Buffer.isBuffer(issuer));
-
-    // Just to check that async really works there
-    setTimeout(function() {
-      callback(null,
-               testOptions.response ? Buffer.from(testOptions.response) : null);
-    }, 100);
-  });
-  server.listen(0, function() {
-    var client = tls.connect({
-      port: this.address().port,
-      requestOCSP: testOptions.ocsp !== false,
-      secureOptions: testOptions.ocsp === false ?
-          SSL_OP_NO_TICKET : 0,
-      rejectUnauthorized: false
-    }, function() {
-      clientSecure++;
-    });
-    client.on('OCSPResponse', function(resp) {
-      ocspResponse = resp;
-      if (resp)
-        client.destroy();
-    });
-    client.on('close', function() {
-      server.close(cb);
-    });
-  });
-
-  process.on('exit', function() {
-    if (testOptions.ocsp === false) {
-      assert.equal(requestCount, clientSecure);
-      assert.equal(requestCount, 1);
-      return;
-    }
-
-    if (testOptions.response) {
-      assert.equal(ocspResponse.toString(), testOptions.response);
-    } else {
-      assert.ok(ocspResponse === null);
-    }
-    assert.equal(requestCount, testOptions.response ? 0 : 1);
-    assert.equal(clientSecure, requestCount);
-    assert.equal(ocspCount, 1);
-  });
-}
-
-var tests = [
-  { response: false },
-  { response: 'hello world' },
-  { ocsp: false }
-];
-
-if (!common.hasFipsCrypto) {
-  tests.push({ pfx: pfx, passphrase: 'sample', response: 'hello pfx' });
-}
-
-function runTests(i) {
-  if (i === tests.length) return;
-
-  test(tests[i], common.mustCall(function() {
-    runTests(i + 1);
-  }));
-}
-
-runTests(0);
diff --git a/test/parallel/test-tls-pfx-gh-5100-regr.js b/test/parallel/test-tls-pfx-gh-5100-regr.js
deleted file mode 100644
index 4670d9e..0000000
--- a/test/parallel/test-tls-pfx-gh-5100-regr.js
+++ /dev/null
@@ -1,40 +0,0 @@
-'use strict';
-
-const common = require('../common');
-
-if (!common.hasCrypto) {
-  common.skip('node compiled without crypto.');
-  return;
-}
-
-const assert = require('assert');
-const tls = require('tls');
-const fs = require('fs');
-const path = require('path');
-
-const pfx = fs.readFileSync(
-    path.join(common.fixturesDir, 'keys', 'agent1-pfx.pem'));
-
-const server = tls.createServer({
-  pfx: pfx,
-  passphrase: 'sample',
-  requestCert: true,
-  rejectUnauthorized: false
-}, common.mustCall(function(c) {
-  assert.strictEqual(
-    c.authorizationError,
-    null,
-    'authorizationError must be null'
-  );
-  c.end();
-})).listen(0, function() {
-  var client = tls.connect({
-    port: this.address().port,
-    pfx: pfx,
-    passphrase: 'sample',
-    rejectUnauthorized: false
-  }, function() {
-    client.end();
-    server.close();
-  });
-});
diff --git a/test/parallel/test-tls-securepair-server.js b/test/parallel/test-tls-securepair-server.js
deleted file mode 100644
index 24ac217..0000000
--- a/test/parallel/test-tls-securepair-server.js
+++ /dev/null
@@ -1,133 +0,0 @@
-'use strict';
-var common = require('../common');
-var assert = require('assert');
-
-if (!common.hasCrypto) {
-  common.skip('missing crypto');
-  return;
-}
-var tls = require('tls');
-
-var join = require('path').join;
-var net = require('net');
-var fs = require('fs');
-var spawn = require('child_process').spawn;
-
-var key = fs.readFileSync(join(common.fixturesDir, 'agent.key')).toString();
-var cert = fs.readFileSync(join(common.fixturesDir, 'agent.crt')).toString();
-
-function log(a) {
-  console.error('***server*** ' + a);
-}
-
-var server = net.createServer(common.mustCall(function(socket) {
-  log('connection fd=' + socket.fd);
-  var sslcontext = tls.createSecureContext({key: key, cert: cert});
-  sslcontext.context.setCiphers('RC4-SHA:AES128-SHA:AES256-SHA');
-
-  var pair = tls.createSecurePair(sslcontext, true);
-
-  assert.ok(pair.encrypted.writable);
-  assert.ok(pair.cleartext.writable);
-
-  pair.encrypted.pipe(socket);
-  socket.pipe(pair.encrypted);
-
-  log('i set it secure');
-
-  pair.on('secure', function() {
-    log('connected+secure!');
-    pair.cleartext.write('hello\r\n');
-    log(pair.cleartext.getPeerCertificate());
-    log(pair.cleartext.getCipher());
-  });
-
-  pair.cleartext.on('data', function(data) {
-    log('read bytes ' + data.length);
-    pair.cleartext.write(data);
-  });
-
-  socket.on('end', function() {
-    log('socket end');
-  });
-
-  pair.cleartext.on('error', function(err) {
-    log('got error: ');
-    log(err);
-    log(err.stack);
-    socket.destroy();
-  });
-
-  pair.encrypted.on('error', function(err) {
-    log('encrypted error: ');
-    log(err);
-    log(err.stack);
-    socket.destroy();
-  });
-
-  socket.on('error', function(err) {
-    log('socket error: ');
-    log(err);
-    log(err.stack);
-    socket.destroy();
-  });
-
-  socket.on('close', function(err) {
-    log('socket closed');
-  });
-
-  pair.on('error', function(err) {
-    log('secure error: ');
-    log(err);
-    log(err.stack);
-    socket.destroy();
-  });
-}));
-
-var gotHello = false;
-var sentWorld = false;
-var gotWorld = false;
-
-server.listen(0, common.mustCall(function() {
-  // To test use: openssl s_client -connect localhost:8000
-
-  var args = ['s_client', '-connect', `127.0.0.1:${this.address().port}`];
-
-  // for the performance and stability issue in s_client on Windows
-  if (common.isWindows)
-    args.push('-no_rand_screen');
-
-  var client = spawn(common.opensslCli, args);
-
-
-  var out = '';
-
-  client.stdout.setEncoding('utf8');
-  client.stdout.on('data', function(d) {
-    out += d;
-
-    if (!gotHello && /hello/.test(out)) {
-      gotHello = true;
-      client.stdin.write('world\r\n');
-      sentWorld = true;
-    }
-
-    if (!gotWorld && /world/.test(out)) {
-      gotWorld = true;
-      client.stdin.end();
-    }
-  });
-
-  client.stdout.pipe(process.stdout, { end: false });
-
-  client.on('exit', common.mustCall(function(code) {
-    assert.strictEqual(0, code);
-    server.close();
-  }));
-}));
-
-process.on('exit', function() {
-  assert.ok(gotHello);
-  assert.ok(sentWorld);
-  assert.ok(gotWorld);
-});
diff --git a/test/parallel/test-tls-sni-option.js b/test/parallel/test-tls-sni-option.js
deleted file mode 100644
index 42d6a90..0000000
--- a/test/parallel/test-tls-sni-option.js
+++ /dev/null
@@ -1,170 +0,0 @@
-'use strict';
-if (!process.features.tls_sni) {
-  common.skip('node compiled without OpenSSL or ' +
-              'with old OpenSSL version.');
-  return;
-}
-
-const common = require('../common');
-const assert = require('assert');
-const fs = require('fs');
-
-if (!common.hasCrypto) {
-  common.skip('missing crypto');
-  return;
-}
-var tls = require('tls');
-
-function filenamePEM(n) {
-  return require('path').join(common.fixturesDir, 'keys', n + '.pem');
-}
-
-function loadPEM(n) {
-  return fs.readFileSync(filenamePEM(n));
-}
-
-var serverOptions = {
-  key: loadPEM('agent2-key'),
-  cert: loadPEM('agent2-cert'),
-  requestCert: true,
-  rejectUnauthorized: false,
-  SNICallback: function(servername, callback) {
-    var context = SNIContexts[servername];
-
-    // Just to test asynchronous callback
-    setTimeout(function() {
-      if (context) {
-        if (context.emptyRegression)
-          callback(null, {});
-        else
-          callback(null, tls.createSecureContext(context));
-      } else {
-        callback(null, null);
-      }
-    }, 100);
-  }
-};
-
-var SNIContexts = {
-  'a.example.com': {
-    key: loadPEM('agent1-key'),
-    cert: loadPEM('agent1-cert'),
-    ca: [ loadPEM('ca2-cert') ]
-  },
-  'b.example.com': {
-    key: loadPEM('agent3-key'),
-    cert: loadPEM('agent3-cert')
-  },
-  'c.another.com': {
-    emptyRegression: true
-  }
-};
-
-var clientsOptions = [{
-  port: undefined,
-  key: loadPEM('agent1-key'),
-  cert: loadPEM('agent1-cert'),
-  ca: [loadPEM('ca1-cert')],
-  servername: 'a.example.com',
-  rejectUnauthorized: false
-}, {
-  port: undefined,
-  key: loadPEM('agent4-key'),
-  cert: loadPEM('agent4-cert'),
-  ca: [loadPEM('ca1-cert')],
-  servername: 'a.example.com',
-  rejectUnauthorized: false
-}, {
-  port: undefined,
-  key: loadPEM('agent2-key'),
-  cert: loadPEM('agent2-cert'),
-  ca: [loadPEM('ca2-cert')],
-  servername: 'b.example.com',
-  rejectUnauthorized: false
-}, {
-  port: undefined,
-  key: loadPEM('agent3-key'),
-  cert: loadPEM('agent3-cert'),
-  ca: [loadPEM('ca1-cert')],
-  servername: 'c.wrong.com',
-  rejectUnauthorized: false
-}, {
-  port: undefined,
-  key: loadPEM('agent3-key'),
-  cert: loadPEM('agent3-cert'),
-  ca: [loadPEM('ca1-cert')],
-  servername: 'c.another.com',
-  rejectUnauthorized: false
-}];
-
-const serverResults = [];
-const clientResults = [];
-const serverErrors = [];
-const clientErrors = [];
-let serverError;
-let clientError;
-
-var server = tls.createServer(serverOptions, function(c) {
-  serverResults.push({ sni: c.servername, authorized: c.authorized });
-});
-
-server.on('tlsClientError', function(err) {
-  serverResults.push(null);
-  serverError = err.message;
-});
-
-server.listen(0, startTest);
-
-function startTest() {
-  function connectClient(i, callback) {
-    var options = clientsOptions[i];
-    clientError = null;
-    serverError = null;
-
-    options.port = server.address().port;
-    var client = tls.connect(options, function() {
-      clientResults.push(
-          /Hostname\/IP doesn't/.test(client.authorizationError || ''));
-      client.destroy();
-
-      next();
-    });
-
-    client.on('error', function(err) {
-      clientResults.push(false);
-      clientError = err.message;
-      next();
-    });
-
-    function next() {
-      clientErrors.push(clientError);
-      serverErrors.push(serverError);
-
-      if (i === clientsOptions.length - 1)
-        callback();
-      else
-        connectClient(i + 1, callback);
-    }
-  }
-
-  connectClient(0, function() {
-    server.close();
-  });
-}
-
-process.on('exit', function() {
-  assert.deepStrictEqual(serverResults, [
-    { sni: 'a.example.com', authorized: false },
-    { sni: 'a.example.com', authorized: true },
-    { sni: 'b.example.com', authorized: false },
-    { sni: 'c.wrong.com', authorized: false },
-    null
-  ]);
-  assert.deepStrictEqual(clientResults, [true, true, true, false, false]);
-  assert.deepStrictEqual(clientErrors, [
-    null, null, null, null, 'socket hang up'
-  ]);
-  assert.deepStrictEqual(serverErrors, [
-    null, null, null, null, 'Invalid SNI context'
-  ]);
-});
diff --git a/test/parallel/test-tls-sni-server-client.js b/test/parallel/test-tls-sni-server-client.js
deleted file mode 100644
index e743078..0000000
--- a/test/parallel/test-tls-sni-server-client.js
+++ /dev/null
@@ -1,116 +0,0 @@
-'use strict';
-if (!process.features.tls_sni) {
-  common.skip('node compiled without OpenSSL or ' +
-              'with old OpenSSL version.');
-  return;
-}
-
-const common = require('../common');
-const assert = require('assert');
-const fs = require('fs');
-
-if (!common.hasCrypto) {
-  common.skip('missing crypto');
-  return;
-}
-var tls = require('tls');
-
-function filenamePEM(n) {
-  return require('path').join(common.fixturesDir, 'keys', n + '.pem');
-}
-
-function loadPEM(n) {
-  return fs.readFileSync(filenamePEM(n));
-}
-
-var serverOptions = {
-  key: loadPEM('agent2-key'),
-  cert: loadPEM('agent2-cert')
-};
-
-var SNIContexts = {
-  'a.example.com': {
-    key: loadPEM('agent1-key'),
-    cert: loadPEM('agent1-cert')
-  },
-  'asterisk.test.com': {
-    key: loadPEM('agent3-key'),
-    cert: loadPEM('agent3-cert')
-  },
-  'chain.example.com': {
-    key: loadPEM('agent6-key'),
-    // NOTE: Contains ca3 chain cert
-    cert: loadPEM('agent6-cert')
-  }
-};
-
-var clientsOptions = [{
-  port: undefined,
-  ca: [loadPEM('ca1-cert')],
-  servername: 'a.example.com',
-  rejectUnauthorized: false
-}, {
-  port: undefined,
-  ca: [loadPEM('ca2-cert')],
-  servername: 'b.test.com',
-  rejectUnauthorized: false
-}, {
-  port: undefined,
-  ca: [loadPEM('ca2-cert')],
-  servername: 'a.b.test.com',
-  rejectUnauthorized: false
-}, {
-  port: undefined,
-  ca: [loadPEM('ca1-cert')],
-  servername: 'c.wrong.com',
-  rejectUnauthorized: false
-}, {
-  port: undefined,
-  ca: [loadPEM('ca1-cert')],
-  servername: 'chain.example.com',
-  rejectUnauthorized: false
-}];
-
-const serverResults = [];
-const clientResults = [];
-
-var server = tls.createServer(serverOptions, function(c) {
-  serverResults.push(c.servername);
-});
-
-server.addContext('a.example.com', SNIContexts['a.example.com']);
-server.addContext('*.test.com', SNIContexts['asterisk.test.com']);
-server.addContext('chain.example.com', SNIContexts['chain.example.com']);
-
-server.listen(0, startTest);
-
-function startTest() {
-  var i = 0;
-  function start() {
-    // No options left
-    if (i === clientsOptions.length)
-      return server.close();
-
-    var options = clientsOptions[i++];
-    options.port = server.address().port;
-    var client = tls.connect(options, function() {
-      clientResults.push(
-        client.authorizationError &&
-        /Hostname\/IP doesn't/.test(client.authorizationError));
-      client.destroy();
-
-      // Continue
-      start();
-    });
-  }
-
-  start();
-}
-
-process.on('exit', function() {
-  assert.deepStrictEqual(serverResults, [
-    'a.example.com', 'b.test.com', 'a.b.test.com', 'c.wrong.com',
-    'chain.example.com'
-  ]);
-  assert.deepStrictEqual(clientResults, [true, true, false, false, true]);
-});
-- 
1.7.1

